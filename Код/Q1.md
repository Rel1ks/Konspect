# Объяснение кода: Проверка арифметической прогрессии

```python
class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        arr = sorted(arr)
        
        diff = arr[1] - arr[0]
        
        for i in range(2, len(arr)):
            if arr[i] - arr[i - 1] != diff:
                return False
        
        return True
```

## Логика алгоритма
**Цель:** Проверить, можно ли переставить элементы массива так, чтобы они образовали [[арифметическую прогрессию]].

### Шаг 1: Сортировка массива
```python
arr = sorted(arr)
```
- **Зачем?** Арифметическая прогрессия требует строгого порядка элементов с постоянной разностью. Сортировка приводит массив к каноническому виду, где проверка разностей становится тривиальной.
- **Пример:**  
  `[3, 5, 1]` → `[1, 3, 5]`  
  `[1, 2, 4]` → `[1, 2, 4]`

### Шаг 2: Вычисление эталонной разности
```python
diff = arr[1] - arr[0]
```
- **Математическое определение:**  
  В арифметической прогрессии разность между соседними элементами постоянна:  
  $d = a_{n+1} - a_n$
- **Почему именно так?**  
  После сортировки массива по возрастанию:
  - `arr[1] ≥ arr[0]`, поэтому `diff` будет ≥ 0
  - Это соответствует стандартному определению прогрессии (например, `[1, 3, 5]` имеет $d = 2$)
- **Контрпример:**  
  Если бы мы вычисляли `arr[0] - arr[1]`, для `[1, 3, 5]` получили бы $d = -2$, что нарушило бы логику проверки.

### Шаг 3: Проверка всех последовательных разностей
```python
for i in range(2, len(arr)):
    if arr[i] - arr[i - 1] != diff:
        return False
```
- **Диапазон итераций:**  
  Цикл начинается с индекса `2`, потому что:
  - Индексы `0` и `1` уже использованы для вычисления `diff`
  - Нужно проверить пары: `(2,1)`, `(3,2)`, ..., `(n-1, n-2)`
- **Условие остановки:**  
  Если хотя бы одна разность не совпадает с `diff`, массив не может быть арифметической прогрессией → немедленный возврат `False`
- **Пример проверки для `[1, 3, 5]`:**
  ```
  i=2: arr[2] - arr[1] = 5 - 3 = 2 == diff (2) → продолжаем
  Цикл завершён → возвращаем True
  ```

### Шаг 4: Успешное завершение
```python
return True
```
- Выполняется только если все разности совпали с `diff`
- **Гарантии:**
  - Для $n = 2$ цикл не запустится → всегда `True` (любые два числа образуют прогрессию)
  - Для $n ≥ 3$ проверены все соседние пары

## Сложность алгоритма
| Параметр       | Значение          | Пояснение                          |
|----------------|-------------------|-----------------------------------|
| **Время**      | $O(n \log n)$     | Доминирующая операция — сортировка |
| **Память**     | $O(1)$ или $O(n)$ | Зависит от реализации `sorted()`   |

## Примеры работы
### Пример 1: `[3, 5, 1]` → `True`
```
1. Сортировка: [1, 3, 5]
2. diff = 3 - 1 = 2
3. Проверка:
   5 - 3 = 2 == diff → True
```

### Пример 2: `[1, 2, 4]` → `False`
```
1. Сортировка: [1, 2, 4]
2. diff = 2 - 1 = 1
3. Проверка:
   4 - 2 = 2 ≠ diff → False
```

## Краевые случаи
| Случай                | Результат | Пояснение                                  |
|-----------------------|-----------|-------------------------------------------|
| `[1, 1, 1]`           | `True`    | $d = 0$ — допустимая прогрессия           |
| `[-3, -1, 1]`         | `True`    | $d = 2$ — прогрессия с отрицательными числами |
| `[1, 100]`            | `True`    | Всегда верно для двух элементов            |

## Почему это работает?
- **Математическая корректность:** Сортировка + проверка разностей гарантирует соответствие определению арифметической прогрессии
- **Эффективность:** Нет лишних вычислений — алгоритм останавливается при первом несовпадении
- **Универсальность:** Работает для любых целых чисел (положительных, отрицательных, нулей)

> **Важно:** Алгоритм предполагает, что входной массив можно переставлять. Если бы требовалось сохранять исходный порядок, потребовался бы другой подход.