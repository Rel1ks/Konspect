# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        # Создаем фиктивный узел (dummy node), который будет служить началом нового списка.
        # Это упрощает обработку случая, когда один из списков пуст или когда нужно вставить первый элемент.
        dummy = ListNode()
        
        # Создаем указатель 'current', который будет двигаться по новому списку и добавлять узлы.
        current = dummy
        
        # Используем цикл while для прохода по обоим спискам до тех пор, пока не дойдем до конца хотя бы одного из них.
        # cравниваем значения текущих узлов в list1 и list2 и выбираем меньший.
        while list1 and list2:
            # Сравниваем значения текущих узлов list1 и list2.
            if list1.val <= list2.val:
                # Если значение в list1 меньше или равно значению в list2,
                # присоединяем узел list1 к новому списку.
                current.next = list1
                # Передвигаем указатель list1 на следующий узел.
                list1 = list1.next
            else:
                # значение в list2 меньше, присоединяем узел list2 к новому списку.
                current.next = list2
                # Передвигаем указатель list2 на следующий узел.
                list2 = list2.next
            
            # Передвигаем указатель current на только что добавленный узел.
            current = current.next
        
        # После завершения цикла, один из списков может быть еще не пустым.
        # присоединяем оставшуюся часть непустого списка к новому списку.
        # Поскольку оба списка были отсортированы, оставшаяся часть уже правильно упорядочена.
        current.next = list1 if list1 else list2


        # Возвращаем head нового списка, который находится после dummy-узла.
        return dummy.next
