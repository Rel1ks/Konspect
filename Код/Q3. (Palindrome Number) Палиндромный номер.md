# Объяснение кода: Проверка числа на палиндром

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        
        s = str(x)
        left, right = 0, len(s) - 1
        
        while left < right:
            if s[left] != s[right]:
                return False 
            left += 1
            right -= 1
        
        return True
```

## Суть алгоритма
**Цель:** Проверить, является ли целое число **палиндромом** (читается одинаково слева направо и справа налево).

[[Палиндром]] — последовательность символов, которая идентична при чтении в обратном направлении. Для чисел это означает:
- Например: `121`, `12321`, `0`
- Не палиндромы: `-121`, `10`, `123`

---

## Пошаговое объяснение

### Шаг 1: Проверка на отрицательные числа
```python
if x < 0:
    return False
```
- **Почему?** Отрицательные числа содержат знак `-` в начале. При обратном чтении знак окажется в конце, что делает число некорректным.
- **Пример:**  
  `-121` → при реверсе получается `121-`, что не равно исходному.

### Шаг 2: Преобразование в строку
```python
s = str(x)
```
- **Зачем?** Работа со строкой позволяет обращаться к отдельным цифрам по индексу.
- **Альтернатива:** Математический подход с делением на 10, но он сложнее для понимания.

### Шаг 3: Два указателя
```python
left, right = 0, len(s) - 1
```
- `left` начинает с **начала** строки (индекс 0)
- `right` начинает с **конца** строки (последний индекс)
- **Визуализация для `121`:**
  ```
  left → "1" "2" "1" ← right
  ```

### Шаг 4: Проверка симметрии
```python
while left < right:
    if s[left] != s[right]:
        return False 
    left += 1
    right -= 1
```
- **Логика:** Сравниваем символы с двух концов, двигаясь к центру:
  1. Если символы не совпадают → число не палиндром
  2. Если совпадают → продолжаем проверку внутренних символов
- **Пример для `121`:**
  ```
  Итерация 1: left=0 ('1'), right=2 ('1') → совпадают
  Итерация 2: left=1, right=1 → цикл завершается (left == right)
  Результат: True
  ```
- **Пример для `123`:**
  ```
  Итерация 1: left=0 ('1'), right=2 ('3') → не совпадают → False
  ```

### Шаг 5: Успешное завершение
```python
return True
```
- Выполняется, если все пары символов совпали.

---

## Примеры работы

### Пример 1: `x = 121`
```
1. x >= 0 → продолжаем
2. s = "121"
3. left=0, right=2:
   - '1' == '1' → двигаем указатели (left=1, right=1)
4. Цикл завершается → возвращаем True
```

### Пример 2: `x = 10`
```
1. x >= 0 → продолжаем
2. s = "10"
3. left=0 ('1'), right=1 ('0'):
   - '1' != '0' → возвращаем False
```

### Пример 3: `x = 0`
```
1. x >= 0 → продолжаем
2. s = "0"
3. left=0, right=0 → цикл не запускается
4. Возвращаем True
```

---

## Анализ сложности

| Параметр       | Значение          | Пояснение                          |
|----------------|-------------------|-----------------------------------|
| **Время**      | $O(n)$            | Где $n$ — количество цифр в числе |
| **Память**     | $O(n)$            | Для хранения строкового представления |

> **Примечание:** Временная сложность линейная, так как мы проверяем максимум $n/2$ пар символов.

---

## Преимущества подхода
1. **Читаемость:** Код интуитивно понятен благодаря использованию строковых операций.
2. **Эффективность:** 
   - Ранний выход при первом несовпадении
   - Минимальное количество операций
3. **Корректность:** 
   - Учитывает краевые случаи (отрицательные числа, однозначные числа)
   - Не создаёт лишних копий данных (в отличие от `s[::-1]`)

---

## Краевые случаи

| Входное число | Результат | Пояснение                                  |
|--------------|-----------|-------------------------------------------|
| `-121`       | `False`   | Отрицательные числа не могут быть палиндромами |
| `0`          | `True`    | Однозначные числа всегда палиндромы        |
| `11`         | `True`    | Симметричное двузначное число              |
| `123454321`  | `True`    | Большой палиндром без оптимизаций          |
| `2147483647` | `False`   | Максимальное 32-битное целое не является палиндромом |

---

## Альтернативные подходы
1. **Реверс числа математически:**
   ```python
   reversed_num = 0
   original = x
   while x > 0:
       reversed_num = reversed_num * 10 + x % 10
       x //= 10
   return original == reversed_num
   ```
   - **Плюсы:** $O(1)$ памяти
   - **Минусы:** Сложнее для понимания, риск переполнения

2. **Сравнение с реверсом строки:**
   ```python
   return str(x) == str(x)[::-1]
   ```
   - **Плюсы:** Краткость
   - **Минусы:** Создаёт новую строку (лишняя память $O(n)$)

---

## Почему этот код эффективен?
- **Минимальные вычисления:** Проверка останавливается при первом несовпадении
- **Оптимальное использование памяти:** Не создаётся копия всей строки
- **Универсальность:** Работает для всех целых чисел из диапазона $[-2^{31}, 2^{31} - 1]$

> **Важно:** Для реальных систем с критичными требованиями к памяти лучше использовать математический подход без преобразования в строку. Но для большинства задач этот вариант оптимален по балансу читаемости и эффективности.
