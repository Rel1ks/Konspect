#Код #LEETCODE 
### Условие  
Для заданного неотрицательного целого числа `n` (количество ступенек) верните количество различных способов добраться до вершины лестницы, если за один раз можно подняться либо на 1, либо на 2 ступеньки.  
Гарантируется, что `1 <= n <= 45`.

Нельзя использовать рекурсию без мемоизации при больших `n` (из-за производительности), но в рамках ограничений допустимы даже простые итеративные решения.
### Код

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        # Самое простое решение: используем итеративный подсчёт,
        # аналогичный последовательности Фибоначчи.
        # f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5, ...
        
        if n == 1:
            return 1
        if n == 2:
            return 2
        
        a, b = 1, 2  # a = f(i-2), b = f(i-1)
        for _ in range(3, n + 1):
            a, b = b, a + b  # сдвигаем значения: новое b = a + b
        
        return b
```
Это решение основано на том, что количество способов подняться на `n`-ю ступеньку равно сумме способов подняться на `(n‑1)`-ю и `(n‑2)`-ю ступеньки — ведь вы можете прийти туда либо с одной, либо с двух ступенек назад.  

Мы начинаем с базовых случаев:
- `n = 1` → 1 способ,
- `n = 2` → 2 способа.

Затем последовательно вычисляем результат для `3, 4, ..., n`, храня только два последних значения (`a` и `b`), что экономит память.  

В конце цикла переменная `b` содержит ответ для `n`.